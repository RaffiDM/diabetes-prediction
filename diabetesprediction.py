# -*- coding: utf-8 -*-
"""diabetesPredcition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w1CBFOBWdfXapgOrBXXOV4emU24cB3hl

## **Proyek Machine Learning Terapan - Raffi Dzaky Mahendra**

### **Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""### **Load Data**

**Informasi tentang atribut dataset**

[Dataset Link](https://www.kaggle.com/datasets/akshaydattatraykhare/diabetes-dataset/data)
- Pregnancies: Untuk menyatakan jumlah kehamilan

- Glucose: Untuk mengekspresikan tingkat Glukosa dalam darah

- BloodPresure: Untuk mengekspresikan pengukuran tekanan darah

- SkinThickness: Untuk mengekspresikan ketebalan kulit

- Insulin: Untuk mengekspresikan tingkat Insulin dalam darah

- BMI: Untuk mengekspresikan indeks masa tubuh

- DiabetesPedigreeFunction: untuk mengungkapkan persentase Diabetes

- Age: Untuk mengekspresikan usia

- Outcome: Untuk menyatakan hasil akhir 1 adalah Ya dan 0 adalah Tidak
"""

df = pd.read_csv('dataset/diabetes.csv')
df.head()

"""### **Data Cleaning**"""

df.info()

df.isnull().sum()

df.duplicated().sum()

"""#### Insight
- Semua fitur sudah bertipe numerik
- Tidak ditemukan adanya missing value pada dataset
- Tidak ditemukan adanya duplicate value dalam dataset
"""

df.describe()

"""#### Insight
- Terdapat nilai minimum yang tidak masuk akal (0) pada fitur 'Glucose', 'BloodPresure', 'SkinThickness', 'Insulin', dan 'BMI'
"""

def replace_zero_with_median(df):
    # Buat salinan DataFrame
    df_cleaned = df.copy()

    # Daftar fitur dengan nilai 0 yang akan diganti dengan median
    zero_value_features = ['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']

    # Ganti nilai 0 dengan NaN untuk semua fitur yang ditentukan
    df_cleaned[zero_value_features] = df_cleaned[zero_value_features].replace(0, np.nan)

    # Untuk setiap fitur, isi NaN berdasarkan median per kelompok outcome
    for feature in zero_value_features:
        # Hitung median untuk setiap kelompok outcome
        median_by_outcome = df_cleaned.groupby('Outcome')[feature].median()

        # Isi missing values berdasarkan kelompok
        for outcome in [0, 1]:
            mask = (df_cleaned['Outcome'] == outcome) & (df_cleaned[feature].isna())
            df_cleaned.loc[mask, feature] = median_by_outcome[outcome]

    return df_cleaned

def remove_outlier(df):
    # Buat salinan DataFrame
    df_cleaned = df.copy()

    # Daftar fitur yang akan dihilangkan outlier-nya
    columns = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']

    # Simpan jumlah data awal
    initial_rows = len(df_cleaned)

    for column in columns:
        # Hitung Q1, Q3, dan IQR
        Q1 = df_cleaned[column].quantile(0.25)
        Q3 = df_cleaned[column].quantile(0.75)
        IQR = Q3 - Q1

        # Tentukan batas bawah dan atas
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Filter data dalam range yang ditentukan
        df_cleaned = df_cleaned[
            (df_cleaned[column] >= lower_bound) &
            (df_cleaned[column] <= upper_bound)
        ]

    removed_rows = initial_rows - len(df_cleaned)

    print(f"Jumlah data awal: {initial_rows}")
    print(f"Jumlah data setelah membersihkan outlier: {len(df_cleaned)}")
    print(f"Jumlah data yang dihapus: {removed_rows}")
    print(f"Persentase data yang dihapus: {(removed_rows/initial_rows*100):.2f}%")

    return df_cleaned

df_cleaned = replace_zero_with_median(df)
df_cleaned = remove_outlier(df_cleaned)

df_cleaned.info()

"""#### Insight
- Identifikasi nilai 0 pada kolom 'Glucose', 'BloodPresure', 'SkinThickness', 'Insulin', dan 'BMI'sebagai missing value dan mengganti nilai tersebut dengan median based on 'Outcome' target.
- Penanganan outlier dengan metode IQR

### **Exploratory Data Analysis**
"""

# Distribusi diabetes outcome
plt.figure(figsize=(10, 6))
ax = sns.countplot(data=df_cleaned, x='Outcome')

# Menambahkan nilai pada grafik
for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'),
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha = 'center', va = 'center',
                xytext = (0, 9),
                textcoords = 'offset points')

plt.title('Distribution Diabetes Outcome')
plt.show()

plt.figure(figsize=(15, 10))
for i, column in enumerate(['Glucose', 'BMI', 'Age', 'BloodPressure'], 1):
    plt.subplot(2, 2, i)
    sns.histplot(data=df_cleaned, x=column, hue='Outcome', multiple="stack", bins=30)
    plt.title(f'Distribution of {column} by Outcome')
plt.tight_layout()
plt.show()

"""### **Data Preparation**"""

X = df_cleaned.drop(columns='Outcome', axis=1)
y = df_cleaned['Outcome']

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print(f"Jumlah data training: {len(X_train)}")
print(f"Jumlah data testing: {len(X_test)}")

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""### **Model Development**

- Random Forest Model
"""

from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier

param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

grid_search = GridSearchCV(
    estimator=RandomForestClassifier(random_state=42),
    param_grid=param_grid,
    cv=5,
    scoring='accuracy',
    n_jobs=-1
)

grid_search.fit(X_train_scaled, y_train)

# Model terbaik
best_model = grid_search.best_estimator_
print("Model Terbaik:")
print(best_model)
print("\n")

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Prediksi
y_pred = best_model.predict(X_test_scaled)

print("Best Hyperparameters:", grid_search.best_params_)
print("\nModel Performance Metrics:")
print(f"Accuracy: {accuracy_score(y_test, y_pred):.4f}")
print(f"Precision: {precision_score(y_test, y_pred):.4f}")
print(f"Recall: {recall_score(y_test, y_pred):.4f}")
print(f"F1 Score: {f1_score(y_test, y_pred):.4f}")

from sklearn.metrics import confusion_matrix

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)

# Plot Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Tidak Diabetes', 'Diabetes'],
            yticklabels=['Tidak Diabetes', 'Diabetes'])
plt.title('Confusion Matrix')
plt.xlabel('Prediksi')
plt.ylabel('Aktual')
plt.tight_layout()
plt.show()